{"name":"clone.js nano","tagline":"The true prototype-based nano-framework in three lines of JavaScript","body":"clone.js nano\r\n=====\r\n\r\nThe [true prototype-based⠙](http://en.wikipedia.org/wiki/Prototype-based_programming) nano-framework.\r\nThis is the main function of the framework:\r\n```php\r\nfunction clone(/** Object */proto, /** object.literalOnly! */ownProperties){\r\n    ownProperties.__proto__ = proto;\r\n    return ownProperties;\r\n}\r\n```\r\nThe `__proto__` is a part of [upcoming ECMA Script 6⠙](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-B.2.2.1) standart. It should be [relased by December 2013⠙](http://ecma-international.org/memento/TC39-M.htm).  \r\nCurrently, all major browsers have `__proto__` support, except Internet Explorer.  \r\n**This** `clone` **function can be also implemented through** `Object.create` **or function-constructors (JavaScript 1.0 / IE3.0)**.  \r\n\r\n### Try the true prototype-based OOP\r\n\r\nWith this framework you can easilly create and manipulate objects without constructors, instead of classic js way,\r\nwhere you should define a constructor for every object (that you want to use as prototype), even if you didn't need it.\r\nIt's possible to build and maintain extremely **large numbers of \"classes\" with comparatively little code**.\r\n\r\n**It's trivial to create new \"classes\"** - just clone the object and change a couple of properties and voila... new \"class\".\r\n\r\n**It's really class-free**: `clone()` produces objects (prototypes), not function-constructors, unlike all other class-producing tools (`Ext.define`, `dojo.declare` etc).\r\n\r\nRead more:\r\n\r\n- [Advantages of prototype-based OOP⠙](http://programmers.stackexchange.com/questions/110936/what-are-the-advantages-of-prototype-based-oop-over-class-based-oop#answers-header)\r\nby Mike Anderson\r\n- [Does JavaScript need classes? (in russian)⠙](http://habrahabr.ru/post/175029/) [(robot translation)⠙](http://translate.google.com/translate?hl=&sl=ru&tl=en&u=http%3A%2F%2Fhabrahabr.ru%2Fpost%2F175029%2F)\r\nby Me (Alexander Shvets)\r\n- [Myth: JavaScript needs classes⠙](http://www.2ality.com/2011/11/javascript-classes.html)\r\nby [Dr. Axel Rauschmayer (University of Munich)⠙](http://rauschma.de)\r\n- [JS Objects: De”construct”ion⠙](http://davidwalsh.name/javascript-objects-deconstruction)\r\nby Kyle Simpson\r\n- [Stop Using Constructor Functions In JavaScript⠙](http://ericleads.com/2012/09/stop-using-constructor-functions-in-javascript/)\r\nby [Eric Elliott (Adobe)⠙](http://ericleads.com/about/)\r\n- [Constructors Are Bad For JavaScript⠙](http://tareksherif.ca/blog/2013/08/constructors-are-bad-for-javascript/)\r\nby Tarek Sherif\r\n\r\n### It really fast!\r\n\r\nIt faster than any other framework, even VanillaJS! Yes, it creates class-objects faster than JS core creates class-functions!  \r\nSee http://jsperf.com/fw-class-creation/3 and http://jsperf.com/clonejs-nano-vs-vanillajs/5\r\n[![CloneJS Nano vs VanillaJS](http://quadroid.github.io/clonejs-nano/frameworks-class-creation-bench.png)](http://jsperf.com/fw-class-creation/3)\r\n\r\n### What is the Clone?\r\n\r\n`clone` function produces new objects — Clones.  \r\n**Clone — this is the lazy shallow copy**, i.e., it is actually not a copy, it's just a reference to the object,\r\nwith one difference: if you will add/replace any of its properties, it would not affect the cloned object (prototype).  \r\nAll JavaScript objects are clones of `Object.prototype` (except itself and objects, created by `Object.create(null)`). \r\n\r\n### How to use\r\n\r\nForget about classes (function-constructors).    \r\nInstead of **creating class** (function), create prototype (object):\r\n```javascript\r\nvar duck$ = {// $ postfix means prototype: duck$ === Duck.prototype\r\n    name:  \"Duck\",\r\n    color: \"\",\r\n    canFly: true,\r\n    quack: function(){\r\n        console.log( this.name +\": Quack-quack!\");\r\n    }\r\n};\r\n```\r\n*The classic way:*\r\n```javascript\r\nvar Duck = function(name, color, canFly){\r\n    this.name  = name  || \"Duck\";\r\n    this.color = color || \"\";\r\n    this.canFly= canFly === undefined ? true : canFly;  \r\n}\r\nDuck.prototype.quack = function(){\r\n    console.log(this.name +\": Quack-quack!\");\r\n}\r\n```\r\n**Inheritance** is simple (talkingDuck prototype extends duck prototype):\r\n```javascript\r\nvar talkingDuck$ = clone(duck$, {\r\n    firstName: \"\",\r\n    lastName: \"Duck\",\r\n    \r\n    quack: function(){\r\n        duck$.quack.call(this);\r\n        console.log(\"My name is \"+ this.name +\"!\");\r\n    },\r\n    // backward compatibility with duck$ interface:\r\n    get name(){\r\n        return (this.firstName +\" \"+ this.lastName).trim();\r\n    },\r\n    set name(newName){\r\n        var names = newName.split(\" \");\r\n        this.firstName = names[0];\r\n        if(names.length > 1){\r\n            this.lastName = names[1];\r\n        }\r\n    }    \r\n});\r\n```\r\n*The classic way:*\r\n```javascript\r\nvar TalkingDuck = function(firstName, lastName, color, canFly){\r\n    this.firstName = firstName;\r\n    this.lastName = lastName || \"Duck\";\r\n    this.color = color || \"\";\r\n    this.canFly= canFly === undefined ? true : canFly;\r\n}\r\nvar TalkingDuckPrototype = function(){};\r\nTalkingDuckPrototype.prototype = Duck.prototype;\r\nTalkingDuck.prototype = new TalkingDuckPrototype;\r\nTalkingDuck.prototype.constructor = TalkingDuck;\r\nTalkingDuck.prototype.quack = function(){\r\n    Duck.prototype.quack.call(this);\r\n    console.log(\"My name is \"+ this.name +\"!\");\r\n}\r\n// backward compatibility with Duck interface:\r\nObject.defineProperty(TalkingDuck.prototype, 'name', {\r\n    get: function(){\r\n        return (this.firstName +\" \"+ this.lastName).trim();\r\n    },\r\n    set: function(newName){\r\n        var names = newName.split(\" \");\r\n        this.firstName = names[0];\r\n        if(names.length > 1){\r\n            this.lastName = names[1];\r\n        }\r\n    }\r\n});\r\n```\r\nForget about **the `new` operator**, use `clone` to create instances:\r\n```javascript\r\nvar donald = clone(talkingDuck$, {firstName: \"Donald\", color: \"White\", canFly: false});\r\ndonald.quack();// Donald Duck: Quack-quack! \r\n               // My name is Donald!\r\n```\r\n*The classic way:*\r\n```javascript\r\nvar daffy = new TalkingDuck(\"Daffy\", undefined, \"Black\", false);\r\ndaffy.quack();// Daffy Duck: Quack-quack! \r\n               // My name is Daffy!\r\n```\r\nForget about **the `instanceof` operator**, use JS native `.isPrototypeOf()` method instead:\r\n```javascript\r\nduck$.isPrototypeOf(donald);// true\r\n```\r\n*The classic way:*\r\n```javascript\r\ndaffy instanceof Duck;// true\r\n```\r\n\r\n#### Why not Object.create?\r\n\r\n1) Because its second argument isn't usable:\r\n```javascript\r\nvar talkingDuck$ = Object.create(duck$, {\r\n    firstName: {value:\"\", enumerable:true, writable:true},\r\n    lastName: {value:\"Duck\", enumerable:true, writable:true},\r\n\r\n    quack: {value: function(){\r\n        duck$.quack.call(this);\r\n        console.log(\"My name is \"+ this.name +\"!\");\r\n    }}\r\n});\r\n```\r\n2) It's very slow.\r\n\r\n#### Object-oriented notation\r\n\r\nCreate the root prototype for all your objects:\r\n```javascript\r\nvar object$ = {\r\n    clone: function(ownProperties){\r\n        ownProperties.__proto__ = this;\r\n        return ownProperties;\r\n    }\r\n}\r\n```\r\nAfter that, you can clone it:\r\n```javascript\r\nvar duck$ = object$.clone({\r\n    name: \"Duck\",\r\n    quack: function(){\r\n        console.log(this.name +\": Quack-quack!\");\r\n    }\r\n});\r\n\r\nvar donald = duck$.clone({name: \"Donald Duck\"});\r\n```\r\nor just copy its `clone` method to your prototype:\r\n```javascript\r\nvar duck$ = {\r\n    clone: object$.clone,\r\n    name: \"Duck\",\r\n    quack: function(){\r\n        console.log(this.name +\": Quack-quack!\");\r\n    }\r\n};\r\n\r\nvar donald = duck$.clone({name: \"Donald Duck\"});\r\n```\r\n\r\n#### How to initialize object by calculated value?  \r\n**1st way** — use constructor:\r\n```javascript\r\nvar obj$ = {\r\n    base: 1000,\r\n    constructor: function(num){\r\n        this.num = this.base + num;\r\n    }\r\n}\r\nobj$.constructor.prototype = obj$;\r\n\r\nvar obj = new obj$.constructor(777);\r\n```\r\n**The second, more interesting way — [lazy initialization](//github.com/quadroid/clonejs#lazy-initialization)**\r\n\r\n----\r\nIf you like the idea, plese look at the extended version of this framework www.github.com/quadroid/clonejs\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}